#include<iostream>
using namespace std;

//题干:
//约瑟夫环问题
//给定一个链表头节点head，和一个正数m从头开始，
//每次数到m就杀死当前节点然后被杀节点的下一个节点从1开始重新数周而复始直到只剩一个节点，
//返回最后的节点
//题解:
//因为在删除一个节点之后,从下一个节点开始为1,继续计数m个然后删除
//删到最后肯定只剩下一个元素就是返回节点.这个过程涉及到每个节点的重新编号变化.
//最后返回节点的编号一定为1,然后只有一个返回
//如果做,肯定是O(n*m)的,一共删除n-1个节点,每次删除一个节点都涉及到数m次
//
//删除的操作很复杂不好模拟,所以转换对编号的处理
//如果有个函数func(),我给他我现在的下标,让他返回在上一个轮转时我的下标.
//那么,我给他ret节点下标肯定是1,那么func就能告诉我在上一轮有两个节点时ret的下标,...
//就能知道在最开始ret所在下标,然后把他返回即可.
//这种逆过程,就不需要删除节点了

//编号=>报数,编号=(报数-1)%i+1
//前=(后+(m-1))%i+1
//https://image-1309381344.cos.ap-nanjing.myqcloud.com/img/image-20230826174932445.png
class Solution
{
public:
	//题干要求编号是从0~n-1,那我用约瑟夫环算完之后下标-1就是返回值
	int lastRemaining(int n, int m)
	{
		return getLive(n,m)-1;
	}
private:
	//给定编号1~n的情况下,遇到m就删除
	int getLive(int n, int m)
	{
		if (n == 1)
			return 1;
		return (getLive(n - 1, m) + m - 1) % n + 1;
	}
};