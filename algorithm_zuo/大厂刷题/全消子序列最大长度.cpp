//1)在某一个子序列中，如果1的左边有0，那么这两个字符->”01"可以消除
//2)在某一个子序列中，如果'3的左边有2"，那么这两个字符->"23”可以消除
//3)当这个子序列的某个部分消除之后，认为其他字符会自动贴在一起，
// 可以继续寻找消除的机会比如，某个子序列"0231"，先消除掉”23"，
// 那么剩下的字符贴在一起变成"01"，继续消除就没有字符了
// 如果某个子序列通过最优良的方式，可以都消掉，那么这样的子序列叫做“全消子序列”
// 一个只由'0"、"1'、'2'3四种字符组成的字符串str，
// 可以生成很多子序列，返回“全消子序列”的最大长度字符串
// str长度 <= 200

//范围上尝试,返回[l,r]区间能消掉的最长字符字符串的长度
//考虑[L]位置的字符是否选中

#include<iostream>
using namespace std;
class Solution
{
public:
	int func(string& str,int l,int r)
	{
		if (l >= r)//区间不存在或者只有一个字符,不能消掉,能消掉的字符串长度自然为0
			return 0;
		if (l == r - 1)
			return (str[l] == '0' && str[r] == '1') || 
					(str[l] == '2' && str[r] == '3')? 2 : 0;
		//1. L位置不考虑
		int p1 = func(str, l + 1, r);
		//2. L 位置需要考虑,只能是L位置是0 或者 2
		if (str[l] != '0' && str[l] != '2')
			return p1;
		//是0或者2,
		//需要在之后的区间中,将所有能够匹配的字符都找出来匹配一遍*******
		//看看其中能够达到能够消除的最长的字符串的长度
		char find = str[l] == '0' ? '1' : '3';
		int p2 = 0;
		for (int i = l + 1; i < r; i++)
		{
			if (str[i] == find)
			{
				//p2 = 消除的两个字符+ [l+1,r-1]区间获取的最大长度+[i+1,r]区间获取的最大长度
				p2 = max(p2, func(str, l + 1, i - 1) + 2 + func(str, i + 1, r));
			}
		}
		return max(p1, p2);
	}
};